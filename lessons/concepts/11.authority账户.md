Q1: where authority account is stored?

**Answer:**
The authority account (mint_authority) is stored in the **Mint account's data structure** on-chain.

When a token mint is initialized, the `mint_authority` pubkey is written into the Mint account's account data. This is a persistent field that can be read by any program that deserializes the Mint account.

In the code flow:
- `initializeLaunch.rs:44` - The `token_mint` account is passed as mutable
- The Mint account data structure contains fields like:
  - `mint_authority: COption<Pubkey>` - The authority that can mint tokens
  - `freeze_authority: COption<Pubkey>` - The authority that can freeze accounts
  - `supply: u64` - Current token supply
  - `decimals: u8` - Token decimals

The Mint account is stored on-chain and can be read by programs to verify who has minting authority.


Q2: where authority account is checked?

**Answer:**
Authority account is checked at **two levels**:

**1. Runtime Level (Signer Verification) - `agave/program-runtime/src/invoke_context.rs:294-475`**

In `prepare_next_instruction()`, the runtime verifies that if an account is marked as `is_signer` in the CPI instruction, it must satisfy one of:
- Be a signer in the caller instruction, OR  
- Be in the `signers` list (derived from PDA seeds via `translate_signers`)

Key code location:
```rust
// Line 429-434 in invoke_context.rs
if instruction_account.is_signer()
    && !(caller_instruction_account.is_signer() || signers.contains(account_key))
{
    return Err(InstructionError::PrivilegeEscalation);
}
```

The `signers` list comes from `translate_signers()` in `cpi.rs:914-921`, which derives PDAs from seeds using `Pubkey::create_program_address()`.

**2. Program Level (Authority Matching) - SPL Token Program**

The SPL Token program itself checks:
- Reads `mint_authority` from the Mint account's data
- Verifies the provided authority account matches the stored `mint_authority`
- Verifies the authority account is a signer (already validated by runtime)

In the example code (`initializeLaunch.rs:144-155`):
- `ctx.accounts.launch_signer` is passed as the authority
- `signer_seeds` are provided to derive the PDA signature
- The runtime verifies the PDA can sign (via `translate_signers`)
- The Token program verifies the authority matches the mint's `mint_authority`

**Security Note:** The vulnerability in `initializeLaunch.rs` is that it doesn't verify `launch_signer` matches the expected PDA before using it. The runtime only verifies the PDA can sign, but doesn't check if it's the correct PDA for this mint operation.



Q3: Authority account 
BL7Cxn3wxkQJRVTw4xME7pNBsS81R6a6P8RCDPwp6sCC

Validation :
 [29] [prepare_next_instruction] Account BL7Cxn3wxkQJRVTw4xME7pNBsS81R6a6P8RCDPwp6sCC privilege check - callee: signer=true, writable=true, caller: signer=true, writable=true, in_signers=false



Q4: 