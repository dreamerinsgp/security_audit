使用 PDA seeds 作为 signer 进行 CPI 时，Solana 需要验证 authority 账户与 seeds 派生的 PDA 匹配。

背景：
  token::mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.token_mint.to_account_info(),
                    to: ctx.accounts.token_vault.to_account_info(),
                    authority: ctx.accounts.launch_signer.to_account_info(),
                },
                signer_seeds,
            ),
            AVAILABLE_TOKENS,
        )?;

验证逻辑：

是的，你这句话在语义上是正确的，不过可以更精确一点表述。  

在 Solana 里，**当你在 `invoke_signed` / `CpiContext::new_with_signer` 中提供 `signer_seeds` 时，运行时会用这些 seeds + 当前程序 ID 去重新派生 PDA，并检查：**  

1. 用 `program_id + seeds + bump` 重新派生出的地址，是否等于你在账户列表里传入的那个账户的 pubkey（这里就是 `launch_signer`）。[(1)](https://solana.com/docs/core/pda)[(2)](https://solana.com/docs/references/terminology)  
2. 只有在这个检查通过时，这个 PDA 才会被视为“已签名”，可以作为 `authority` 来通过签名检查（例如 SPL Token 的 `mint_to` CPI 中的 `authority`）。[(1)](https://solana.com/docs/core/pda)[(2)](https://solana.com/docs/references/terminology)  

所以，更准确地说：  

> 在 CPI 中使用 `signer_seeds` 时，Solana 会用这些 seeds 和当前程序 ID 重新派生 PDA，并验证“由这些 seeds 派生出来的 PDA 地址”与 **你传入的那个账户的地址** 是否一致；只有一致时，这个账户才被视为签名者。[(1)](https://solana.com/docs/core/pda)[(2)](https://solana.com/docs/references/terminology)  

这就等价于你说的“验证 authority 账户与从 `signer_seeds` 派生的 PDA 是否匹配”，前提是你把 `authority` 账户设成那个 PDA（这里是 `launch_signer`）。[(1)](https://solana.com/docs/core/pda)[(2)](https://solana.com/docs/references/terminology)



完整流程：
代码:
  signer_seeds = [b"launch_signer", launch_key, bump]
  ↓
CPI 调用:
  CpiContext::new_with_signer(..., signer_seeds)
  ↓
cpi.rs:translate_signers_c():
  使用 program_id + seeds 派生 PDA
  Pubkey::create_program_address(seeds, program_id)
  → 返回 PDA 地址列表: [9dD2pVMKDUHWkdUjsuaM4G3eYb1PMXk13vVXeaeKqitJ]
  ↓
invoke_context.rs:prepare_next_instruction():
  检查 authority 账户是否在 signers 列表中
  signers.contains(account_key)
  ↓
验证结果:
  ✅ 如果 account_key == PDA → 验证通过
  ❌ 如果 account_key != PDA → PrivilegeEscalation 错误

## UncheckedAccount 类型的问题排查

### 问题现象
即使 PDA 地址和 bump 都正确，仍然出现 "Cross-program invocation with unauthorized signer or writable account" 错误。

### 可能原因
1. **账户不在账户列表中**：`UncheckedAccount` 没有 PDA 约束时，Anchor 可能无法正确将账户添加到账户列表
2. **账户所有者不正确**：PDA 账户的所有者必须是派生它的程序
3. **账户属性设置错误**：账户的 `is_signer`、`is_writable` 等属性可能不正确

### 解决方案
添加 PDA 约束，让 Anchor 正确处理账户：

```rust
#[account(
    seeds = [b"launch_signer", launch.key().as_ref()],
    bump
)]
pub launch_signer: UncheckedAccount<'info>,
```

### 验证逻辑（基于 agave/runtime 源码）

**1. Seeds 转 PDA** (`agave/program-runtime/src/cpi.rs:792`)
```rust
Pubkey::create_program_address(&seeds_bytes, program_id)
```
- 使用 `program_id + seeds` 派生 PDA
- 返回 PDA 地址列表

**2. Signer 验证** (`agave/program-runtime/src/invoke_context.rs:396-401`)
```rust
if instruction_account.is_signer()
    && !(caller_instruction_account.is_signer() || signers.contains(account_key))
{
    return Err(InstructionError::PrivilegeEscalation);
}
```
- 检查账户是否在 `signers` 列表中（从 seeds 派生的 PDA 地址列表）
- 如果不在列表中，返回 `PrivilegeEscalation` 错误

### 调试日志

为了便于调试 CPI 验证流程，已在以下位置添加了日志：

**1. CPI 入口日志** (`agave/program-runtime/src/cpi.rs:cpi_common`)
- 记录 signer seeds 的转换开始
- 记录派生出的 signers 列表
- 记录准备指令的详细信息

**2. PDA 派生日志** (`agave/program-runtime/src/cpi.rs:translate_signers_c`)
- 使用 `eprintln!` 记录每个 PDA 的派生过程
- 显示 seeds 数量和派生出的 PDA 地址

**3. Signer 验证日志** (`agave/program-runtime/src/invoke_context.rs:prepare_next_instruction`)
- 记录每个账户的 signer 验证过程
- 显示账户是否在 caller 中签名、是否在 signers 列表中
- 显示完整的 signers 列表用于对比

**查看日志的方法：**

1. **使用 agave 本地节点运行测试：**
   ```bash
   cd /root/solana-security-audit
   ./start-agave-node.sh
   # 在另一个终端
   export ANCHOR_PROVIDER_URL="http://localhost:8899"
   anchor test --skip-local-validator
   ```

2. **日志会出现在：**
   - `eprintln!` 输出会显示在验证器的标准错误输出中
   - `ic_msg!` 输出会出现在交易日志中（可通过 RPC 获取）

3. **过滤日志：**
   ```bash
   # 查看验证器日志中的 CPI 调试信息
   tail -f test-ledger/validator.log | grep "CPI DEBUG\|SIGNER VERIFY\|SEEDS->PDA"
   ```

4. **在测试中查看日志：**
   ```typescript
   // 在测试中，日志会出现在交易结果中
   const tx = await program.methods.initializeLaunch({})
     .accounts({...})
     .rpc();
   
   // 查看交易日志
   console.log(await provider.connection.getTransaction(tx, { commitment: 'confirmed' }));
   ```

### 关键发现
- **PDA 约束是必需的**：即使使用 `UncheckedAccount`，也需要 PDA 约束才能让 Anchor 正确设置账户信息
- **Anchor 会自动处理**：有了 PDA 约束后，Anchor 会：
  1. 验证账户地址匹配 PDA
  2. 将账户正确添加到账户列表
  3. 设置正确的账户属性（所有者、is_signer 等）