1. 执行 ./start-agave-node.sh


2. 执行 anchor test  --skip-local-validator


3. anchor-spl anchor-lang  solana-invoke 全部采用本地依赖，方便调试
https://github.com/solana-foundation/solana-invoke
https://github.com/solana-foundation/anchor


4. 完整调用链 【TODO:】
继续解释这些文件之间的关系：


[4 tools called]


解释这些文件之间的关系和调用流程：


[3 tools called]


## `sol_invoke_signed_rust` 的调用链关系

### 调用流程概览

```
程序代码 (solana-invoke)
    ↓ 调用
sol_invoke_signed_rust() [syscall]
    ↓ 运行时拦截
Agave 运行时注册的 syscall 处理函数
    ↓ 执行
SyscallInvokeSignedRust::vm
    ↓ 调用
cpi_common() → translate_signers_rust() → CPI 执行
```

### 详细关系说明

#### 1. 程序端：`/root/solana-invoke/invoke/src/lib.rs`

```rust
// 第42-43行：Solana 环境 - 导入真实的 syscall 声明
#[cfg(target_os = "solana")]
use solana_define_syscall::definitions::sol_invoke_signed_rust;
// ↑ 这个声明告诉编译器：sol_invoke_signed_rust 是一个外部 syscall
//   实际实现由运行时提供

// 第45-48行：非 Solana 环境 - 占位函数
#[cfg(not(target_os = "solana"))]
unsafe fn sol_invoke_signed_rust(...) -> u64 {
    unimplemented!("only supported with `target_os = \"solana\"")
}
// ↑ 仅用于本地编译/测试，避免链接错误

// 第60行：实际调用
sol_invoke_signed_rust(
    instruction_addr,
    account_infos as *const _ as *const u8,
    account_infos.len() as u64,
    signers_seeds as *const _ as *const u8,
    signers_seeds.len() as u64,
)
// ↑ 在 Solana 环境下，这会触发 syscall，被运行时拦截
```

#### 2. 运行时注册：`/root/agave/syscalls/src/lib.rs:444`

```rust
result.register_function("sol_invoke_signed_rust", SyscallInvokeSignedRust::vm)?;
// ↑ 将字符串 "sol_invoke_signed_rust" 与 SyscallInvokeSignedRust::vm 函数关联
//   当程序调用 sol_invoke_signed_rust syscall 时，运行时就会调用这个处理函数
```

作用：
- 注册 syscall 名称到处理函数的映射
- 程序调用 `sol_invoke_signed_rust` 时，运行时路由到 `SyscallInvokeSignedRust::vm`

#### 3. Syscall 实现：`/root/agave/syscalls/src/cpi.rs`

```rust
// 第11-33行：定义 SyscallInvokeSignedRust
declare_builtin_function!(
    SyscallInvokeSignedRust,
    fn rust(
        invoke_context: &mut InvokeContext,
        instruction_addr: u64,
        account_infos_addr: u64,
        account_infos_len: u64,
        signers_seeds_addr: u64,
        signers_seeds_len: u64,
        memory_mapping: &mut MemoryMapping,
    ) -> Result<u64, Error> {
        cpi_common::<Self>(...)  // 调用通用的 CPI 处理逻辑
    }
);

// 第35-78行：实现翻译逻辑
impl SyscallInvokeSigned for SyscallInvokeSignedRust {
    fn translate_signers(...) -> Result<Vec<Pubkey>, Error> {
        translate_signers_rust(...)  // ← 这里会调用你之前添加日志的地方！
    }
}
```

作用：
- 提供 syscall 的实际处理逻辑
- 调用 `cpi_common`，最终调用 `translate_signers_rust`（你添加日志的位置）

#### 4. 测试环境：`/root/agave/svm/tests/mock_bank.rs:398-400`

```rust
loader
    .register_function("sol_invoke_signed_rust", SyscallInvokeSignedRust::vm)
    .expect("Registration failed");
// ↑ 在测试环境中注册相同的 syscall，用于单元测试
```

### 完整调用链

```
1. Anchor 程序调用
   anchor-spl/src/token.rs::mint_to()
   ↓
2. 调用 solana-invoke
   solana-invoke/invoke/src/lib.rs::invoke_signed_unchecked()
   ↓
3. 调用 syscall
   sol_invoke_signed_rust() [syscall 调用]
   ↓
4. Agave 运行时拦截
   agave/syscalls/src/lib.rs:444 注册的函数映射
   ↓
5. 执行处理函数
   agave/syscalls/src/cpi.rs::SyscallInvokeSignedRust::vm()
   ↓
6. 调用 CPI 通用逻辑
   agave/program-runtime/src/cpi.rs::cpi_common()
   ↓
7. 翻译签名者
   agave/program-runtime/src/cpi.rs::translate_signers_rust()
   ↓ [你添加日志的地方！]
8. 执行 CPI
   调用目标程序
```

### 关键点

1. `solana-invoke/invoke/src/lib.rs:45-48` 的占位函数：
   - 仅在非 Solana 环境编译
   - 避免链接错误，不参与实际执行

2. `agave/syscalls/src/lib.rs:444` 的注册：
   - 建立 syscall 名称到处理函数的映射
   - 程序调用 syscall 时，运行时路由到对应处理函数

3. `agave/syscalls/src/cpi.rs` 的实现：
   - 提供 syscall 的实际处理逻辑
   - 最终调用 `translate_signers_rust`（你添加日志的位置）

### 总结

- `solana-invoke/invoke/src/lib.rs:45-48`：占位函数，仅用于非 Solana 环境编译
- `agave/syscalls/src/lib.rs:444`：运行时注册，将 syscall 名称映射到处理函数
- `agave/syscalls/src/cpi.rs`：syscall 的实际实现，处理 CPI 调用
- `agave/svm/tests/mock_bank.rs:398-400`：测试环境中的相同注册，用于单元测试

它们共同构成了从程序代码到运行时执行的完整调用链。